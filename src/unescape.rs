// See the normative reference for HTML5 entities:
// https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references
//
// Some entities do not require a trailing semicolon. Some of those entities
// are prefixes for multiple other entities. For example:
//   &times &times; &timesb; &timesbar; &timesd;

// Include the ENTITIES array generated by build.rs
include!(concat!(env!("OUT_DIR"), "/entities.rs"));

enum SearchResult {
    Exact(&'static [u8]),
    ExactPlusPrefix(&'static [u8]),
    Prefix,
    None,
}

// This does not assume that ENTITIES is sorted.
fn find_entity_by_prefix<S: AsRef<[u8]>>(needle: S) -> SearchResult {
    let needle = needle.as_ref();
    let mut found: &[u8] = &[];
    let mut found_prefix = false;

    for (entity, expansion) in ENTITIES.iter() {
        if entity.starts_with(needle) {
            if entity.len() == needle.len() { // => entity == needle
                if found != [] {
                    panic!("Found two identical entities in ENTITIES: {:?}",
                        entity);
                }

                found = &expansion;
            } else {
                found_prefix = true;
            }

            if found_prefix && found != [] {
                return SearchResult::ExactPlusPrefix(found);
            }
        }
    }

    if found_prefix {
        SearchResult::Prefix
    } else if found != [] {
        SearchResult::Exact(found)
    } else {
        SearchResult::None
    }
}

// Expects the initial & to already have been consumed.
fn match_entity(iter: &mut dyn Iterator<Item = &u8>) -> Vec<u8> {
    let mut buffer = vec![b'&'];
    let mut candidate = vec![b'&'];

    while let Some(c) = iter.next() {
        buffer.push(*c);
        candidate.push(*c);
        match find_entity_by_prefix(&buffer) {
            SearchResult::Exact(expansion) => {
                return expansion.into();
            },
            SearchResult::ExactPlusPrefix(expansion) => {
                // We match an entity exactly as well as at least one other
                // entity as a prefix.
                candidate.truncate(0);
                candidate.extend_from_slice(expansion);
            },
            SearchResult::Prefix => {
            },
            SearchResult::None => {
                return candidate;
            }
        }
    }

    candidate
}

pub fn unescape<S: AsRef<[u8]>>(escaped: S) -> String {
    let escaped = escaped.as_ref();
    let mut iter = escaped.iter();
    let mut buffer = Vec::new();

    while let Some(c) = iter.next() {
        if *c == b'&' {
            buffer.append(&mut match_entity(&mut iter));
        } else {
            buffer.push(*c);
        }
    }

    String::from_utf8(buffer).unwrap()
}

#[cfg(test)]
mod tests {
    use super::*;

    test_eq!(almost_entity, unescape, "&time", "&time");
    test_eq!(exact_no_semicolon, unescape, "&times", "×");
    test_eq!(exact, unescape, "&times;", "×");
    test_eq!(entity_char, unescape, "&timesa", "×a");
    test_eq!(entity_char_is_prefix, unescape, "&timesb", "×b");
    test_eq!(exact_timesb, unescape, "&timesb;", "⊠");

    test_eq!(no_entities, unescape, "none", "none");
    test_eq!(middle_entity, unescape, " &amp; ", " & ");
    test_eq!(extra_ampersands, unescape, "&&amp;&", "&&&");
    test_eq!(two_entities, unescape, "AND &amp;&AMP; and", "AND && and");
}
