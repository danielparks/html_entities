// See the normative reference for HTML5 entities:
// https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references
//
// Entities do not always require a trailing semicolon, though the exact rules
// depend on whether the entity appears in an attribute value or somewhere else.
// See [`unescape_in()`] for more information.
//
// Some entities are prefixes for multiple other entities. For example:
//   &times &times; &timesb; &timesbar; &timesd;

use std::borrow::Cow;
use std::char;
use std::cmp::min;
use std::num::IntErrorKind;
use std::result::Result;
use std::slice;

// Include the ENTITIES map generated by build.rs
include!(concat!(env!("OUT_DIR"), "/entities.rs"));

/// The context for an input string (requires `unescape` feature).
///
/// Either `Attribute` for strings from an attribute value, or `General` for
/// everything else.
///
/// See [`unescape_in()`] for usage.
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum Context {
    General,
    Attribute,
}

/// Expand all valid entities (requires `unescape` feature).
///
/// This is appropriate to use on any text outside of an attribute. See
/// [`unescape_in()`] for more information.
///
pub fn unescape<'a, S: Into<Cow<'a, str>>>(escaped: S) -> Cow<'a, str> {
    unescape_in(escaped, Context::General)
}

/// Expand all valid entities in an attribute (requires `unescape` feature).
///
/// This is only appropriate for the value of an attribute. See
/// [`unescape_in()`] for more information.
///
/// [specifies]: https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
pub fn unescape_attribute<'a, S: Into<Cow<'a, str>>>(
    escaped: S,
) -> Cow<'a, str> {
    unescape_in(escaped, Context::Attribute)
}

/// Expand all valid entities in a given context (requires `unescape` feature).
///
/// `context` may be:
///
///   * `Context::General`: use the rules for text outside of an attribute.
///      This is usually what you want.
///   * `Context::Attribute`: use the rules for attribute values.
///
/// This uses the [algorithm described] in the WHATWG spec. In attributes,
/// [named entities] without trailing semicolons are treated differently. They
/// not expanded if they are followed by an alphanumeric character or or `=`.
///
/// For example:
///
/// ```rust
/// use htmlize::*;
/// use assert2::check;
///
/// check!(unescape_in("&times",   Context::General)   == "×");
/// check!(unescape_in("&times",   Context::Attribute) == "×");
/// check!(unescape_in("&times;X", Context::General)   == "×X");
/// check!(unescape_in("&times;X", Context::Attribute) == "×X");
/// check!(unescape_in("&timesX",  Context::General)   == "×X");
/// check!(unescape_in("&timesX",  Context::Attribute) == "&timesX");
/// check!(unescape_in("&times=",  Context::General)   == "×=");
/// check!(unescape_in("&times=",  Context::Attribute) == "&times=");
/// check!(unescape_in("&times#",  Context::General)   == "×#");
/// check!(unescape_in("&times#",  Context::Attribute) == "×#");
/// ```
///
/// [algorithm described]: https://html.spec.whatwg.org/multipage/parsing.html#character-reference-state
/// [named entities]: https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
pub fn unescape_in<'a, S: Into<Cow<'a, str>>>(
    escaped: S,
    context: Context,
) -> Cow<'a, str> {
    let escaped = escaped.into();

    // Use .as_bytes().iter() since .bytes() doesn’t provide .as_slice().
    let mut remainder = escaped.as_bytes();
    let mut iter = remainder.iter();

    if let Some(i) = position_peek(&mut iter, |&c| c == b'&') {
        // All but two entities are as long or longer than their expansion, so
        // allocating the output buffer to be the same size as the input will
        // usually prevent multiple allocations and generally won’t
        // over-allocate by very much.
        //
        // The two entities are `&nGg;` (≫⃒) and `&nLl;` (≪⃒) which are both five
        // byte entities with six byte expansions.
        let mut buffer = Vec::with_capacity(escaped.len());

        buffer.extend_from_slice(&remainder[0..i]);
        buffer.extend_from_slice(&match_entity(&mut iter, context));
        remainder = iter.as_slice();

        while let Some(i) = position_peek(&mut iter, |&c| c == b'&') {
            buffer.extend_from_slice(&remainder[0..i]);
            buffer.extend_from_slice(&match_entity(&mut iter, context));
            remainder = iter.as_slice();
        }

        buffer.extend_from_slice(remainder);

        String::from_utf8(buffer).unwrap().into()
    } else {
        escaped
    }
}

const PEEK_MATCH_ERROR: &str =
    "iter.next() did not match previous iter.as_slice().first()";

fn match_entity(iter: &mut slice::Iter<u8>, context: Context) -> Vec<u8> {
    let remainder = iter.as_slice();
    assert!(
        Some(&b'&') == remainder.first(),
        "iter.as_slice().first() returned different values"
    );

    if let Some(&b'#') = remainder.get(1) {
        // Numeric entity.
        return match_numeric_entity(iter);
    }

    assert!(Some(&b'&') == iter.next(), "{}", PEEK_MATCH_ERROR);

    // Determine longest possible candidate including & and any trailing ;.
    let mut candidate = vec![b'&'];
    candidate.extend_from_slice(&consume_alphanumeric(iter));

    match iter.as_slice().first() {
        Some(&b';') => {
            // Actually consume the semicolon.
            candidate.push(*iter.next().expect(PEEK_MATCH_ERROR));
        }
        Some(b'=') if context == Context::Attribute => {
            // Special case, see https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
            // In an attribute, entities ending with an alphanumeric character
            // or '=' instead of ';' are passed through without expansion. This
            // match statement will never find an alphanumeric character because
            // we consume them all above.
            //
            // Note that the longest entity will always end with a ';' since any
            // bare entity should always have a closed version with a trailing
            // semicolon, which by definition will be longer.
            return candidate;
        }
        _ => {
            // missing-semicolon-after-character-reference: ignore and continue.
            // https://html.spec.whatwg.org/multipage/parsing.html#parse-error-missing-semicolon-after-character-reference
        }
    }

    if candidate.len() < ENTITY_MIN_LENGTH {
        // Couldn’t possibly match.
        return candidate;
    }

    if context == Context::Attribute {
        // If candidate does not exactly match an entity, then don't expand it.
        // This is because of the special case described in the spec (see
        // https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state)
        // Essentially it says that *in attributes* entities must be terminated
        // with a semicolon, EOF, or some character *other* than [a-zA-Z0-9=].
        //
        // In other words, “&timesa” expands to “&timesa” in an attribute rather
        // than “×a”.
        if let Some(expansion) = ENTITIES.get(&candidate) {
            return expansion.to_vec();
        }
    } else {
        // Find longest matching entity.
        let max_len = min(candidate.len(), ENTITY_MAX_LENGTH);
        for check_len in (ENTITY_MIN_LENGTH..=max_len).rev() {
            if let Some(expansion) = ENTITIES.get(&candidate[..check_len]) {
                // Found a match.
                let mut result = Vec::with_capacity(
                    expansion.len() + candidate.len() - check_len,
                );
                result.extend_from_slice(expansion);

                if check_len < candidate.len() {
                    // Need to append the rest of the consumed bytes.
                    result.extend_from_slice(&candidate[check_len..]);
                }

                return result;
            }
        }
    }

    // Did not find a match.
    candidate
}

#[allow(clippy::from_str_radix_10)]
fn match_numeric_entity(iter: &mut slice::Iter<u8>) -> Vec<u8> {
    let remainder = iter.as_slice();
    assert!(Some(&b'&') == iter.next(), "{}", PEEK_MATCH_ERROR);
    assert!(Some(&b'#') == iter.next(), "{}", PEEK_MATCH_ERROR);

    let number = match iter.as_slice().first() {
        c @ (Some(&b'x') | Some(&b'X')) => {
            // Hexadecimal entity
            assert!(c == iter.next(), "{}", PEEK_MATCH_ERROR);

            let hex = slice_while(iter, u8::is_ascii_hexdigit);
            u32::from_str_radix(&String::from_utf8(hex.to_vec()).unwrap(), 16)
        }
        Some(_) => {
            // Presumably a decimal entity
            let dec = slice_while(iter, u8::is_ascii_digit);
            u32::from_str_radix(&String::from_utf8(dec.to_vec()).unwrap(), 10)
        }
        None => {
            // Iterator reached end
            return remainder.to_vec();
        }
    };

    if let Some(&b';') = iter.as_slice().first() {
        assert!(Some(&b';') == iter.next(), "{}", PEEK_MATCH_ERROR);
    } else {
        // missing-semicolon-after-character-reference: ignore and continue.
        // https://html.spec.whatwg.org/multipage/parsing.html#parse-error-missing-semicolon-after-character-reference
    }

    match number {
        Ok(number) => {
            return correct_numeric_entity(number).to_vec();
        }
        Err(error) => match error.kind() {
            IntErrorKind::PosOverflow => {
                // Too large a number
                return REPLACEMENT_CHAR_BYTES.to_vec();
            }
            IntErrorKind::Empty => {
                // No number, e.g. &#; or &#x;. Fall through.
            }
            // Pretty sure this is impossible.
            _ => panic!("error parsing number in numeric entity: {:?}", error),
        },
    }

    // Get the slice up to the current position of iter.
    remainder[..remainder.len() - iter.as_slice().len()].to_vec()
}

/// Unicode replacement character (U+FFFD “�”, requires `unescape` feature)
///
/// According to the WHATWG HTML spec, this is used as an expansion for certain
/// invalid numeric entities.
///
/// According to Unicode 12, this is “used to replace an incoming character
/// whose value is unknown or unrepresentable in Unicode.” The latest chart for
/// the Specials block is [available as a PDF](https://www.unicode.org/charts/PDF/UFFF0.pdf).
pub const REPLACEMENT_CHAR_BYTES: &[u8] = "\u{fffd}".as_bytes();

// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
fn correct_numeric_entity(number: u32) -> Cow<'static, [u8]> {
    match number {
        // null-character-reference parse error:
        0x00 => REPLACEMENT_CHAR_BYTES.into(),

        // character-reference-outside-unicode-range parse error:
        0x110000.. => REPLACEMENT_CHAR_BYTES.into(),

        // https://infra.spec.whatwg.org/#surrogate
        // surrogate-character-reference parse error:
        0xD800..=0xDFFF => REPLACEMENT_CHAR_BYTES.into(),

        // control-character-reference parse error exceptions:
        0x80 => "\u{20AC}".as_bytes().into(), // EURO SIGN (€)
        0x82 => "\u{201A}".as_bytes().into(), // SINGLE LOW-9 QUOTATION MARK (‚)
        0x83 => "\u{0192}".as_bytes().into(), // LATIN SMALL LETTER F WITH HOOK (ƒ)
        0x84 => "\u{201E}".as_bytes().into(), // DOUBLE LOW-9 QUOTATION MARK („)
        0x85 => "\u{2026}".as_bytes().into(), // HORIZONTAL ELLIPSIS (…)
        0x86 => "\u{2020}".as_bytes().into(), // DAGGER (†)
        0x87 => "\u{2021}".as_bytes().into(), // DOUBLE DAGGER (‡)
        0x88 => "\u{02C6}".as_bytes().into(), // MODIFIER LETTER CIRCUMFLEX ACCENT (ˆ)
        0x89 => "\u{2030}".as_bytes().into(), // PER MILLE SIGN (‰)
        0x8A => "\u{0160}".as_bytes().into(), // LATIN CAPITAL LETTER S WITH CARON (Š)
        0x8B => "\u{2039}".as_bytes().into(), // SINGLE LEFT-POINTING ANGLE QUOTATION MARK (‹)
        0x8C => "\u{0152}".as_bytes().into(), // LATIN CAPITAL LIGATURE OE (Œ)
        0x8E => "\u{017D}".as_bytes().into(), // LATIN CAPITAL LETTER Z WITH CARON (Ž)
        0x91 => "\u{2018}".as_bytes().into(), // LEFT SINGLE QUOTATION MARK (‘)
        0x92 => "\u{2019}".as_bytes().into(), // RIGHT SINGLE QUOTATION MARK (’)
        0x93 => "\u{201C}".as_bytes().into(), // LEFT DOUBLE QUOTATION MARK (“)
        0x94 => "\u{201D}".as_bytes().into(), // RIGHT DOUBLE QUOTATION MARK (”)
        0x95 => "\u{2022}".as_bytes().into(), // BULLET (•)
        0x96 => "\u{2013}".as_bytes().into(), // EN DASH (–)
        0x97 => "\u{2014}".as_bytes().into(), // EM DASH (—)
        0x98 => "\u{02DC}".as_bytes().into(), // SMALL TILDE (˜)
        0x99 => "\u{2122}".as_bytes().into(), // TRADE MARK SIGN (™)
        0x9A => "\u{0161}".as_bytes().into(), // LATIN SMALL LETTER S WITH CARON (š)
        0x9B => "\u{203A}".as_bytes().into(), // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (›)
        0x9C => "\u{0153}".as_bytes().into(), // LATIN SMALL LIGATURE OE (œ)
        0x9E => "\u{017E}".as_bytes().into(), // LATIN SMALL LETTER Z WITH CARON (ž)
        0x9F => "\u{0178}".as_bytes().into(), // LATIN CAPITAL LETTER Y WITH DIAERESIS (Ÿ)

        // A few parse errors and other cases are handled by the catch-all.
        //
        //   * noncharacter-character-reference parse error
        //   * control-character-reference parse error
        //   * 0x0d (carriage return)
        //   * ASCII whitespace
        //   * ASCII control characters
        //
        // I found the spec a little confusing here, but a close reading and
        // some browser testing convinced me that all of these cases are handled
        // but just emitting the represented code point.

        // Everything else.
        c => char::from_u32(c)
            .map(|c| c.to_string().into_bytes().into())
            // Should never fall back since we handle all the cases above.
            .unwrap_or_else(|| REPLACEMENT_CHAR_BYTES.into()),
    }
}

macro_rules! consumer {
    ($name:ident, $($accept:pat)|+) => {
        fn $name(iter: &mut slice::Iter<u8>) -> Vec<u8> {
            let mut buffer: Vec<u8> = Vec::new();
            while let Some(c) = iter.as_slice().first() {
                match *c {
                    $($accept)|+ => {
                        buffer.push(*iter.next().expect(PEEK_MATCH_ERROR));
                    },
                    _ => { return buffer; },
                }
            }

            return buffer;
        }
    }
}

consumer!(consume_alphanumeric, b'0'..=b'9' | b'a'..=b'z' | b'A'..=b'Z');

#[inline]
fn slice_while<'a, P>(
    iter: &mut slice::Iter<'a, u8>,
    mut predicate: P,
) -> &'a [u8]
where
    P: FnMut(&u8) -> bool,
{
    slice_until(iter, move |c| !predicate(c))
}

#[inline]
fn slice_until<'a, P>(iter: &mut slice::Iter<'a, u8>, predicate: P) -> &'a [u8]
where
    P: FnMut(&u8) -> bool,
{
    let remainder = iter.as_slice();
    if let Some(i) = position_peek(iter, predicate) {
        &remainder[..i]
    } else {
        remainder
    }
}

/// Like `position()`, but stops _before_ the found value.
#[inline]
fn position_peek<P>(
    iter: &mut slice::Iter<u8>,
    mut predicate: P,
) -> Option<usize>
where
    P: FnMut(&u8) -> bool,
{
    try_fold_peek(
        iter,
        0,
        move |i, x| {
            if predicate(x) {
                Err(i)
            } else {
                Ok(i + 1)
            }
        },
    )
    .err()
}

/// Like try_fold(), but stops _before_ the found value.
///
/// The passed function should return `Ok(_)` to continue to next value, or
/// `Err(_)` to stop with the iterator pointing at the previous value — i.e. the
/// next call to `iter.next()` will return the value currently being processed.
///
/// This uses `&u8` instead of `u8` so that you can pass `u8::is_ascii_digit` as
/// a predicate to `position_peek()` and friends.
#[inline]
fn try_fold_peek<T, F>(
    iter: &mut slice::Iter<u8>,
    initial: T,
    mut function: F,
) -> Result<T, T>
where
    F: FnMut(T, &u8) -> Result<T, T>,
{
    let mut accumulator = initial;
    for c in iter.as_slice() {
        accumulator = function(accumulator, c)?;
        iter.next();
    }
    Ok(accumulator)
}

#[cfg(test)]
mod tests {
    use super::*;
    use paste::paste;

    // Test both unescape and unescape_attribute
    macro_rules! test_both {
        ($name:ident, unescape $($test:tt)+) => {
            #[test]
            fn $name() {
                ::assert2::assert!(unescape$($test)+);
            }

            paste! {
                #[test]
                fn [<attribute_ $name>]() {
                    ::assert2::assert!(unescape_attribute$($test)+);
                }
            }
        };
    }

    test_both!(almost_entity, unescape("&time") == "&time");
    test_both!(exact_times, unescape("&times;") == "×");
    test_both!(exact_timesb, unescape("&timesb;") == "⊠");
    test_both!(bare_times_end, unescape("&times") == "×");
    test_both!(bare_times_bang, unescape("&times!") == "×!");

    test!(bare_entity_char, unescape("&timesa") == "×a");
    test!(bare_entity_equal, unescape("&times=") == "×=");
    test!(bare_entity_char_is_prefix, unescape("&timesb") == "×b");
    test!(
        attribute_bare_entity_char,
        unescape_attribute("&timesa") == "&timesa"
    );
    test!(
        attribute_bare_entity_equal,
        unescape_attribute("&times=") == "&times="
    );
    test!(
        attribute_bare_entity_char_is_prefix,
        unescape_attribute("&timesb") == "&timesb"
    );

    test_both!(empty, unescape("") == "");
    test_both!(no_entities, unescape("none") == "none");
    test_both!(only_ampersand, unescape("&") == "&");
    test_both!(empty_entity, unescape("&;") == "&;");
    test_both!(middle_entity, unescape(" &amp; ") == " & ");
    test_both!(extra_ampersands, unescape("&&amp;&") == "&&&");
    test_both!(two_entities, unescape("AND &amp;&AMP; and") == "AND && and");
    test_both!(
        long_entity,
        unescape("&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;")
            == "&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;"
    );

    test_both!(correct_hex_lowerx_lower, unescape("&#x7a;") == "z");
    test_both!(correct_hex_lowerx_upper, unescape("&#x7A;") == "z");
    test_both!(correct_hex_upperx_lower, unescape("&#X7a;") == "z");
    test_both!(correct_hex_upperx_upper, unescape("&#X7A;") == "z");
    test_both!(correct_hex_leading_zero, unescape("&#x07a;") == "z");
    test_both!(correct_hex_leading_zero_zero, unescape("&#x007a;") == "z");
    test_both!(correct_dec, unescape("&#122;") == "z");
    test_both!(correct_dec_leading_zero, unescape("&#0122;") == "z");
    test_both!(correct_dec_leading_zero_zero, unescape("&#00122;") == "z");
    test_both!(correct_hex_unicode, unescape("&#x21D2;") == "⇒");

    test_both!(bare_hex_char, unescape("&#x7Az") == "zz");
    test_both!(bare_hex_end, unescape("&#x7A") == "z");
    test_both!(bare_dec_char, unescape("&#122z") == "zz");
    test_both!(bare_dec_end, unescape("&#122") == "z");

    test_both!(hex_instead_of_dec, unescape("&#a0;") == "&#a0;");
    test_both!(invalid_hex_lowerx, unescape("&#xZ;") == "&#xZ;");
    test_both!(invalid_hex_upperx, unescape("&#XZ;") == "&#XZ;");

    test_both!(hex_control_1, unescape("&#x1;") == "\u{1}");
    test_both!(dec_control_1, unescape("&#1;") == "\u{1}");
    test_both!(dec_cr, unescape("&#13;") == "\r");
    test_both!(hex_cr, unescape("&#xd;") == "\r");
    test_both!(hex_tab, unescape("&#9;") == "\t");
    test_both!(dec_tab, unescape("&#9;") == "\t");

    test_both!(hex_max_code_point, unescape("&#x10ffff;") == "\u{10ffff}");
    test_both!(
        hex_above_max_code_point,
        unescape("&#x110001;") == "\u{fffd}"
    );
    test_both!(hex_11_chars, unescape("&#x1100000000;") == "\u{fffd}");
    test_both!(
        bare_hex_11_chars_end,
        unescape("&#x1100000000") == "\u{fffd}"
    );

    test_both!(
        hex_40_chars,
        unescape("&#x110000000000000000000000000000000000000;") == "\u{fffd}"
    );
    test_both!(
        bare_hex_40_chars_end,
        unescape("&#x110000000000000000000000000000000000000") == "\u{fffd}"
    );

    test_both!(special_entity_null, unescape("&#0;") == "\u{fffd}");
    test_both!(special_entity_bullet, unescape("&#x95;") == "•");
    test_both!(
        special_entity_bullets,
        unescape("&#x95;&#149;&#x2022;•") == "••••"
    );
    test_both!(special_entity_space, unescape("&#x20") == " ");

    const ALL_SOURCE: &str =
        include_str!("../tests/corpus/all-entities-source.txt");
    const ALL_EXPANDED: &str =
        include_str!("../tests/corpus/all-entities-expanded.txt");
    test_both!(all_entities, unescape(ALL_SOURCE) == ALL_EXPANDED);

    #[test]
    fn correct_numeric_entity_euro() {
        match correct_numeric_entity(0x80) {
            Cow::Borrowed(s) => assert!(s == "\u{20AC}".as_bytes()),
            Cow::Owned(_) => panic!("expected borrowed"),
        }
    }

    #[test]
    fn correct_numeric_entity_null() {
        match correct_numeric_entity(0) {
            Cow::Borrowed(s) => assert!(s == "\u{fffd}".as_bytes()),
            Cow::Owned(_) => panic!("expected borrowed"),
        }
    }

    #[test]
    fn correct_numeric_entity_z() {
        match correct_numeric_entity(b'z'.into()) {
            Cow::Borrowed(_) => panic!("expected owned"),
            Cow::Owned(ref s) => assert!(s == b"z"),
        }
    }
}
