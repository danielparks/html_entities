// See the normative reference for HTML5 entities:
// https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references
//
// Some entities do not require a trailing semicolon. Some of those entities
// are prefixes for multiple other entities. For example:
//   &times &times; &timesb; &timesbar; &timesd;

use std::iter::Peekable;

// Include the ENTITIES array generated by build.rs
include!(concat!(env!("OUT_DIR"), "/entities.rs"));

/// Expand all valid entities.
/// FIXME non-named entities.
pub fn unescape<S: AsRef<[u8]>>(escaped: S) -> String {
    let escaped = escaped.as_ref();
    let mut iter = escaped.iter().peekable();
    let mut buffer = Vec::new(); // FIXME Vec::with_capacity(escaped.len())? Shrink on return?

    while let Some(c) = iter.next() {
        if *c == b'&' {
            let mut expansion = match_entity(&mut iter);
            buffer.append(&mut expansion);
        } else {
            buffer.push(*c);
        }
    }

    String::from_utf8(buffer).unwrap()
}

fn match_entity<'a, I>(iter: &mut Peekable<I>) -> Vec<u8>
    where I: Iterator<Item = &'a u8>
{
    let mut partial_entity = vec![b'&'];
    let mut best_expansion = vec![b'&'];

    if let Some(&b'#') = iter.peek() {
        // Numeric entity.
        unimplemented!();
    }

    while let Some(c) = iter.peek() {
        if **c == b'&' {
            // Start of new entity. Don’t consume the '&'.
            return best_expansion;
        }

        // Actually consume the character.
        let c = iter.next().expect("iter.next() did not match previous iter.peek()");

        partial_entity.push(*c);
        best_expansion.push(*c);
        match find_entity_by_prefix(&partial_entity) {
            SearchResult::Exact(expansion) => {
                return expansion.into();
            },
            SearchResult::ExactPlusPrefix(expansion) => {
                // We match an entity exactly as well as at least one other
                // entity as a prefix.
                best_expansion = expansion.into();
            },
            SearchResult::Prefix => {
            },
            SearchResult::None => {
                return best_expansion;
            }
        }
    }

    // Iterator reached end during matching.
    best_expansion
}

enum SearchResult {
    Exact(&'static [u8]),
    ExactPlusPrefix(&'static [u8]),
    Prefix,
    None,
}

// This does not assume that ENTITIES is sorted.
fn find_entity_by_prefix<S: AsRef<[u8]>>(needle: S) -> SearchResult {
    let needle = needle.as_ref();
    let mut found: &[u8] = &[];
    let mut found_prefix = false;

    for (entity, expansion) in ENTITIES.iter() {
        if entity.starts_with(needle) {
            if entity.len() == needle.len() { // => entity == needle
                if found != [] {
                    panic!("Found two identical entities in ENTITIES: {:?}",
                        entity);
                }

                found = &expansion;
            } else {
                found_prefix = true;
            }

            if found_prefix && found != [] {
                return SearchResult::ExactPlusPrefix(found);
            }
        }
    }

    if found_prefix {
        SearchResult::Prefix
    } else if found != [] {
        SearchResult::Exact(found)
    } else {
        SearchResult::None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    test_eq!(almost_entity, unescape, "&time", "&time");
    test_eq!(exact_no_semicolon, unescape, "&times", "×");
    test_eq!(exact, unescape, "&times;", "×");
    test_eq!(entity_char, unescape, "&timesa", "×a");
    test_eq!(entity_char_is_prefix, unescape, "&timesb", "×b");
    test_eq!(exact_timesb, unescape, "&timesb;", "⊠");

    test_eq!(no_entities, unescape, "none", "none");
    test_eq!(middle_entity, unescape, " &amp; ", " & ");
    test_eq!(extra_ampersands, unescape, "&&amp;&", "&&&");
    test_eq!(two_entities, unescape, "AND &amp;&AMP; and", "AND && and");
}
