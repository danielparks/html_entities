// See the normative reference for HTML5 entities:
// https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references
//
// Some entities do not require a trailing semicolon. Some of those entities
// are prefixes for multiple other entities. For example:
//   &times &times; &timesb; &timesbar; &timesd;

// Include the ENTITIES array generated by build.rs
include!(concat!(env!("OUT_DIR"), "/entities.rs"));

enum SearchResult {
    Exact(&'static [u8]),
    ExactPlusPrefix(&'static [u8]),
    Prefix,
    None,
}

// This does not assume that ENTITIES is sorted.
fn find_entity_by_prefix<S: AsRef<[u8]>>(needle: S) -> SearchResult {
    let needle = needle.as_ref();
    let mut found: &[u8] = &[];
    let mut found_prefix = false;

    for (entity, expansion) in ENTITIES.iter() {
        if entity.starts_with(needle) {
            if entity.len() == needle.len() { // => entity == needle
                if found != [] {
                    panic!("Found two identical entities in ENTITIES: {:?}",
                        entity);
                }

                found = &expansion;
            } else {
                found_prefix = true;
            }

            if found_prefix && found != [] {
                return SearchResult::ExactPlusPrefix(found);
            }
        }
    }

    if found_prefix {
        SearchResult::Prefix
    } else if found != [] {
        SearchResult::Exact(found)
    } else {
        SearchResult::None
    }
}

pub fn unescape<S: AsRef<[u8]>>(escaped: S) -> String {
    let escaped = escaped.as_ref();
    let mut iter = escaped.iter();
    let mut buffer = Vec::new();

    'no_entity: while let Some(c) = iter.next() {
        if *c != b'&' {
            buffer.push(*c);
            continue;
        }

        // Found an entity.
        let mut match_buffer = vec![b'&'];
        let mut fallback = vec![b'&'];

        'matching_entity: while let Some(c) = iter.next() {
            if *c == b'&' {
                // Potential start of new entity. End this matching cycle and
                // start a new one.
                buffer.append(&mut fallback);

                match_buffer = vec![b'&'];
                fallback = vec![b'&'];
                continue 'matching_entity;
            }

            match_buffer.push(*c);
            fallback.push(*c);
            match find_entity_by_prefix(&match_buffer) {
                SearchResult::Exact(expansion) => {
                    buffer.extend_from_slice(expansion);
                    continue 'no_entity;
                },
                SearchResult::ExactPlusPrefix(expansion) => {
                    // We match an entity exactly as well as at least one other
                    // entity as a prefix.
                    fallback = expansion.into();
                },
                SearchResult::Prefix => {
                },
                SearchResult::None => {
                    buffer.append(&mut fallback);
                    continue 'no_entity;
                }
            }
        }

        // Iterator ended during matching.
        buffer.append(&mut fallback);
    }

    String::from_utf8(buffer).unwrap()
}

#[cfg(test)]
mod tests {
    use super::*;

    test_eq!(almost_entity, unescape, "&time", "&time");
    test_eq!(exact_no_semicolon, unescape, "&times", "×");
    test_eq!(exact, unescape, "&times;", "×");
    test_eq!(entity_char, unescape, "&timesa", "×a");
    test_eq!(entity_char_is_prefix, unescape, "&timesb", "×b");
    test_eq!(exact_timesb, unescape, "&timesb;", "⊠");

    test_eq!(no_entities, unescape, "none", "none");
    test_eq!(middle_entity, unescape, " &amp; ", " & ");
    test_eq!(extra_ampersands, unescape, "&&amp;&", "&&&");
    test_eq!(two_entities, unescape, "AND &amp;&AMP; and", "AND && and");
}
